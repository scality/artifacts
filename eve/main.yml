---
version: 0.2

branches:
  default:
    stage: pre-merge

models:
  - ShellCommand: &artifacts-log
      logfiles:
        artifacts:
          filename: /logs/artifacts.log
          follow: false
        proxy-cache:
          filename: /logs/proxy-cache.log
          follow: false

stages:
  pre-merge:
    worker:
      type: kube_pod
      path: eve/workers/pod.yml
      images:
        artifacts: "."
        agressor: eve/workers/agressor
        cache: proxy-cache
    steps:
    - Git: &git_pull
        name: git pull
        repourl: "%(prop:git_reference)s"
        mode: full
        method: clobber
        retryFetch: true
        haltOnFailure: true
    - ShellCommand:
        name: give some time to artifact service to wake-up
        command: |
          while [ ! -f /logs/artifacts.log ] || [ ! -f /logs/proxy-cache.log ]
          do
             sleep 1
          done
    - ShellCommand:
        name: check download of non-existent container
        <<: *artifacts-log
        command: "./check_non_existent_download.sh http://127.0.0.1/builds/this_container_does_not_exist/"
    - ShellCommand:
        name: check download of non-existent object
        <<: *artifacts-log
        command: "./check_non_existent_download.sh http://127.0.0.1/builds/%(prop:artifacts_name)s/this_object_does_not_exist"
    - ShellCommand:
        name: generate an empty artifact
        <<: *artifacts-log
        command: |
          mkdir empty
          cd empty
          touch data
        haltOnFailure: True
    - ShellCommand:
        name: upload empty artifact
        <<: *artifacts-log
        command: |
          tar -chvzf artifacts.tar.gz empty/data
          curl --verbose --max-time 3600 -s -T artifacts.tar.gz -X PUT 127.0.0.1/upload/%(prop:artifacts_name)s
    - ShellCommand:
        name: check download of emtpy object
        <<: *artifacts-log
        command: "./check_empty_download.sh http://127.0.0.1/builds/%(prop:artifacts_name)s/empty/data"
    - ShellCommand:
        name: generate an artifact with chunk_size len
        <<: *artifacts-log
        command: |
          mkdir chunk_size
          cd chunk_size
          dd if=/dev/urandom of=data bs=8192 count=1
          sha1sum data > data.sha1
        haltOnFailure: True
    - ShellCommand:
        name: upload artifact with chunk_size len
        <<: *artifacts-log
        command: |
          tar -chvzf artifacts.tar.gz chunk_size/data
          curl --verbose --max-time 3600 -s -T artifacts.tar.gz -X PUT 127.0.0.1/upload/%(prop:artifacts_name)s
    - ShellCommand:
        name: check download of object with chunk_size len
        <<: *artifacts-log
        command: "./check_chunk_size_download.sh http://127.0.0.1/builds/%(prop:artifacts_name)s/chunk_size/data"
    - ShellCommand:
        name: generate a big artifact
        <<: *artifacts-log
        command: |
          mkdir big
          cd big
          dd if=/dev/urandom of=data bs=1M count=3000
          sha1sum data > data.sha1
        haltOnFailure: True
    - ShellCommand:
        name: upload big artifact
        <<: *artifacts-log
        command: |
          tar -chvzf artifacts.tar.gz big/data
          curl --verbose --max-time 3600 -s -T artifacts.tar.gz -X PUT 127.0.0.1/upload/%(prop:artifacts_name)s --progress-bar > /dev/null
    - ShellCommand:
        name: check downloads integrity under stress
        <<: *artifacts-log
        command: "./check_multiple_big_downloads.sh http://127.0.0.1/builds/%(prop:artifacts_name)s/big/data"
